---
title: "initial_point_subset_test"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{initial_point_subset_test}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(EROSBIT)
library(raster)


```

```{r make1}
#points <- EROSBIT::sample_point_df
mask <- EROSBIT::sample_mask
BIT <- as(EROSBIT::sample_BIT, 'BITraster')
BIT@variables <- 'Annual_Herb'
BIT@years <- 1985
BIT@data_directory <- '/mnt/data/FDF_raw_data/MRLC'
stopifnot(validObject(BIT))
```

```{r mask1}
# BITraster inherits from RasterStack and raster-class methods work the same as with a Raster Stack/ Raster Layer
BIT_masked <- raster::mask(BIT, mask, maskvalue = 0)
# now only has annual herb > 15%
```

```{r stratified1}
# take 1000 pixel samples of each: annual herb >15, annual herb <= 15
BIT_stratified <- raster::sampleStratified(mask, size = 1000)
# coordinates for the points
# sample the original raster for those points
BIT@temp_directory <- tempdir()

BIT_from_dataframe <- SubsetPoints(BIT, BIT_stratified, 'Annual_Herb', 1985, parallel = FALSE)

# or, use a SpatialPoints object
# coordinates for the points
c0 <- raster::xyFromCell(BIT, BIT_stratified[, 1])
BIT_spatial <- SpatialPoints(c0, crs(BIT), bbox = bbox(BIT))
BIT_sub_from_spatial <- SubsetPoints(BIT, BIT_spatial, 'Annual_Herb', 1985, parallel = FALSE)
```
